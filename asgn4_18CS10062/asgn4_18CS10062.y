%{  

/* C Declarations and Definitions */

	#include <string.h>
	#include <stdio.h>

	extern int yylex(); // Generated by Flex

	void yyerror(char *s);

%}

%union {  // Placeholder for a value
	int intval;
}

// -------------------------- TOKEN DECLARATION --------------------------------
%token IDENTIFIER
%token CONSTANT
%token STRING_LITERAL

%token ROUND_BRACKET_OPEN ROUND_BRACKET_CLOSE
%token SQUARE_BRACKET_OPEN SQUARE_BRACKET_CLOSE
%token CURLY_BRACKET_OPEN CURLY_BRACKET_CLOSE

%token UNARY_INCREMENT UNARY_DECREMENT NOT
%token MUL DIV MOD PLUS MINUS COMPLEMENT XOR
%token DOT DOTS COMMA QUES_MARK COLON SEMICOLON
%token IMPLIES HASH

%token BITWISE_LEFT BITWISE_RIGHT BITWISE_AND BITWISE_OR
%token LOGICAL_AND LOGICAL_OR
%token LESS_THAN GREATER_THAN LESS_EQUAL GREATER_EQUAL EQUAL NOT_EQUAL

%token ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN PLUS_ASSIGN MINUS_ASSIGN 
%token BITWISE_LEFT_ASSIGN BITWISE_RIGHT_ASSIGN BITWISE_AND_ASSIGN XOR_ASSIGN BITWISE_OR_ASSIGN

%token EXTERN STATIC VOID CHAR SHORT INT LONG FLOAT DOUBLE CONST RESTRICT VOLATILE INLINE SIZEOF TYPEDEF UNION STRUCT

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN 

//Setting precedence for handling Dangling-if-else shift-reduce conflict 
%precedence LOWER_THAN_ELSE
%precedence ELSE

// ------------------------ STATING THE STARTING NON-TERMINAL SYMBOL ------------
%start translation_unit

%%

// -------------------------------- 1. EXPRESSIONS ------------------------------

primary_expression 
		: IDENTIFIER
		{     printf("Rule 1 : EXPRESSIONS : primary_expression\n");}
		| CONSTANT
		{     printf("Rule 1 : EXPRESSIONS : primary_expression\n");}
		| STRING_LITERAL
		{     printf("Rule 1 : EXPRESSIONS : primary_expression\n");}
		| ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE
		{     printf("Rule 1 : EXPRESSIONS : primary_expression\n");}
		;


postfix_expression 
		: primary_expression 
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| postfix_expression SQUARE_BRACKET_OPEN expression SQUARE_BRACKET_CLOSE
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| postfix_expression ROUND_BRACKET_OPEN argument_expression_list_opt ROUND_BRACKET_CLOSE
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| postfix_expression DOT IDENTIFIER
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| postfix_expression IMPLIES IDENTIFIER
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| postfix_expression UNARY_INCREMENT
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| postfix_expression UNARY_DECREMENT
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE 
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE 
		{     printf("Rule 1 : EXPRESSIONS : postfix_expression\n");}
		;


argument_expression_list_opt 
	  	: argument_expression_list
	  	| %empty
	  	;


argument_expression_list 
		: assignment_expression
		{     printf("Rule 1 : EXPRESSIONS : argument_expression_list\n");}
	  	| argument_expression_list COMMA assignment_expression
	    { printf("Rule 1 : EXPRESSIONS : argument_expression_list\n");}
	  	;


unary_expression 
		: postfix_expression
		{     printf("Rule 1 : EXPRESSIONS : unary_expression\n");}
		| UNARY_INCREMENT unary_expression
		{     printf("Rule 1 : EXPRESSIONS : unary_expression\n");}
		| UNARY_DECREMENT unary_expression
		{     printf("Rule 1 : EXPRESSIONS : unary_expression\n");}
		| unary_operator cast_expression
		{     printf("Rule 1 : EXPRESSIONS : unary_expression\n");}
		| SIZEOF unary_expression
		{     printf("Rule 1 : EXPRESSIONS : unary_expression\n");}
		| SIZEOF ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE
		{     printf("Rule 1 : EXPRESSIONS : unary_expression\n");}
		;


unary_operator
		: BITWISE_AND
		{     printf("Rule 1 : EXPRESSIONS : unary_operator\n");}
		| MUL
		{     printf("Rule 1 : EXPRESSIONS : unary_operator\n");}
		| PLUS
		{     printf("Rule 1 : EXPRESSIONS : unary_operator\n");}
		| MINUS
		{     printf("Rule 1 : EXPRESSIONS : unary_operator\n");}
		| COMPLEMENT
		{     printf("Rule 1 : EXPRESSIONS : unary_operator\n");}
		| NOT
		{     printf("Rule 1 : EXPRESSIONS : unary_operator\n");}
		;


cast_expression 
		: unary_expression
		{     printf("Rule 1 : EXPRESSIONS : cast_expression\n");}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE cast_expression
		{     printf("Rule 1 : EXPRESSIONS : cast_expression\n");}
		;


multiplicative_expression 
		: cast_expression
		{     printf("Rule 1 : EXPRESSIONS : multiplicative_expression\n");}
		| multiplicative_expression MUL cast_expression
		{     printf("Rule 1 : EXPRESSIONS : multiplicative_expression\n");}
		| multiplicative_expression DIV cast_expression
		{     printf("Rule 1 : EXPRESSIONS : multiplicative_expression\n");}
		| multiplicative_expression MOD cast_expression
		{     printf("Rule 1 : EXPRESSIONS : multiplicative_expression\n");}
		;


additive_expression 
		: multiplicative_expression
		{     printf("Rule 1 : EXPRESSIONS : additive_expression\n");}
		| additive_expression PLUS multiplicative_expression
		{     printf("Rule 1 : EXPRESSIONS : additive_expression\n");}
		| additive_expression MINUS multiplicative_expression
		{     printf("Rule 1 : EXPRESSIONS : additive_expression\n");}
		;


shift_expression 
		: additive_expression
		{     printf("Rule 1 : EXPRESSIONS : shift_expression\n");}
		| shift_expression BITWISE_LEFT additive_expression
		{     printf("Rule 1 : EXPRESSIONS : shift_expression\n");}
		| shift_expression BITWISE_RIGHT additive_expression
		{     printf("Rule 1 : EXPRESSIONS : shift_expression\n");}
		;


relational_expression 
		: shift_expression
		{     printf("Rule 1 : EXPRESSIONS : relational_expression\n");}
		| relational_expression LESS_THAN shift_expression
		{     printf("Rule 1 : EXPRESSIONS : relational_expression\n");}
		| relational_expression GREATER_THAN shift_expression
		{     printf("Rule 1 : EXPRESSIONS : relational_expression\n");}
		| relational_expression LESS_EQUAL shift_expression
		{     printf("Rule 1 : EXPRESSIONS : relational_expression\n");}
		| relational_expression GREATER_EQUAL shift_expression
		{     printf("Rule 1 : EXPRESSIONS : relational_expression\n");}
		;


equality_expression 
		: relational_expression
		{     printf("Rule 1 : EXPRESSIONS : equality_expression\n");}
		| equality_expression EQUAL relational_expression
		{     printf("Rule 1 : EXPRESSIONS : equality_expression\n");}
		| equality_expression NOT_EQUAL relational_expression
		{     printf("Rule 1 : EXPRESSIONS : equality_expression\n");}
		;


AND_expression 
		: equality_expression
		{     printf("Rule 1 : EXPRESSIONS : AND_expression\n");}
		| AND_expression BITWISE_AND equality_expression
		{     printf("Rule 1 : EXPRESSIONS : AND_expression\n");}
		;


exclusive_OR_expression 
		: AND_expression
		{     printf("Rule 1 : EXPRESSIONS : exclusive_OR_expression\n");}
		| exclusive_OR_expression XOR AND_expression
		{     printf("Rule 1 : EXPRESSIONS : exclusive_OR_expression\n");}
		;


inclusive_OR_expression 
		: exclusive_OR_expression
		{     printf("Rule 1 : EXPRESSIONS : inclusive_OR_expression\n");}
		| inclusive_OR_expression BITWISE_OR exclusive_OR_expression
		{     printf("Rule 1 : EXPRESSIONS : inclusive_OR_expression\n");}
 		;


logical_AND_expression 
		: inclusive_OR_expression
		{     printf("Rule 1 : EXPRESSIONS : logical_AND_expression\n");}
		| logical_AND_expression LOGICAL_AND inclusive_OR_expression
		{     printf("Rule 1 : EXPRESSIONS : logical_AND_expression\n");}
		;


logical_OR_expression 
		: logical_AND_expression
		{     printf("Rule 1 : EXPRESSIONS : logical_OR_expression\n");}
		| logical_OR_expression LOGICAL_OR logical_AND_expression
		{     printf("Rule 1 : EXPRESSIONS : logical_OR_expression\n");}
		;


conditional_expression 
		: logical_OR_expression
		{     printf("Rule 1 : EXPRESSIONS : conditional_expression\n");}
		| logical_OR_expression QUES_MARK expression COLON conditional_expression
		{     printf("Rule 1 : EXPRESSIONS : conditional_expression\n");}
		;


assignment_expression 
		: conditional_expression
		{     printf("Rule 1 : EXPRESSIONS : assignment_expression\n");}
		| unary_expression assignment_operator assignment_expression
		{     printf("Rule 1 : EXPRESSIONS : assignment_expression\n");}
		;


assignment_operator
		: ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| MUL_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| DIV_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| MOD_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| PLUS_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| MINUS_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| BITWISE_LEFT_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| BITWISE_RIGHT_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| BITWISE_AND_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| XOR_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		| BITWISE_OR_ASSIGN
		{     printf("Rule 1 : EXPRESSIONS : assignment_operator\n");}
		;


expression 
		: assignment_expression
		{     printf("Rule 1 : EXPRESSIONS : expression\n");}
		| expression COMMA assignment_expression
		{     printf("Rule 1 : EXPRESSIONS : expression\n");}
		;


constant_expression 
		: conditional_expression
		{     printf("Rule 1 : EXPRESSIONS : constant_expression\n");}
		;


// -------------------------------- 2. DECLARATIONS ------------------------------


declaration 
		: declaration_specifiers init_declarator_list_opt SEMICOLON
		{     printf("Rule 2 : DECLARATIONS : declaration\n");}
		;


init_declarator_list_opt 
		: init_declarator_list
		| %empty
		;


declaration_specifiers 
		: storage_class_specifier declaration_specifiers_opt
		{     printf("Rule 2 : DECLARATIONS : declaration_specifiers\n");}
		| type_specifier declaration_specifiers_opt
		{     printf("Rule 2 : DECLARATIONS : declaration_specifiers\n");}
		| type_qualifier declaration_specifiers_opt
		{     printf("Rule 2 : DECLARATIONS : declaration_specifiers\n");}
		| function_specifier declaration_specifiers_opt
		{     printf("Rule 2 : DECLARATIONS : declaration_specifiers\n");}
		;


declaration_specifiers_opt 
		: declaration_specifiers
		| %empty
		;


init_declarator_list 
		: init_declarator
		{     printf("Rule 2 : DECLARATIONS : init_declarator_list\n");}
		| init_declarator_list COMMA init_declarator
		{     printf("Rule 2 : DECLARATIONS : init_declarator_list\n");}
		;


init_declarator 
		: declarator
		{     printf("Rule 2 : DECLARATIONS : init_declarator\n");}
		| declarator ASSIGN initializer
		{     printf("Rule 2 : DECLARATIONS : init_declarator\n");}
		;


storage_class_specifier 
		: EXTERN
		{     printf("Rule 2 : DECLARATIONS : storage_class_specifier\n");}
		| STATIC
		{     printf("Rule 2 : DECLARATIONS : storage_class_specifier\n");}
		;


type_specifier 
		: VOID
		{     printf("Rule 2 : DECLARATIONS : type_specifier\n");}
		| CHAR
		{     printf("Rule 2 : DECLARATIONS : type_specifier\n");}
		| SHORT
		{     printf("Rule 2 : DECLARATIONS : type_specifier\n");}
		| INT
		{     printf("Rule 2 : DECLARATIONS : type_specifier\n");}
		| LONG
		{     printf("Rule 2 : DECLARATIONS : type_specifier\n");}
		| FLOAT
		{     printf("Rule 2 : DECLARATIONS : type_specifier\n");}
		| DOUBLE
		{     printf("Rule 2 : DECLARATIONS : type_specifier\n");}
		;


specifier_qualifier_list 
		: type_specifier specifier_qualifier_list_opt
		{     printf("Rule 2 : DECLARATIONS : specifier_qualifier_list\n");}
		| type_qualifier specifier_qualifier_list_opt
		{     printf("Rule 2 : DECLARATIONS : specifier_qualifier_list\n");}
		;


specifier_qualifier_list_opt 
		: specifier_qualifier_list
		| %empty
		;


type_qualifier 
		: CONST
		{     printf("Rule 2 : DECLARATIONS : type_qualifier\n");}
		| RESTRICT
		{     printf("Rule 2 : DECLARATIONS : type_qualifier\n");}
		| VOLATILE
		{     printf("Rule 2 : DECLARATIONS : type_qualifier\n");}
		;


function_specifier 
		: INLINE
		{     printf("Rule 2 : DECLARATIONS : function_specifier\n");}
		;


declarator 
		: pointer_opt direct_declarator
		{     printf("Rule 2 : DECLARATIONS : declarator\n");}
		;


direct_declarator 
		: IDENTIFIER
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		| ROUND_BRACKET_OPEN declarator ROUND_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list_opt assignment_expression_opt SQUARE_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		| direct_declarator SQUARE_BRACKET_OPEN STATIC type_qualifier_list_opt assignment_expression SQUARE_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list STATIC assignment_expression SQUARE_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list_opt MUL SQUARE_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		| direct_declarator ROUND_BRACKET_OPEN parameter_type_list ROUND_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		| direct_declarator ROUND_BRACKET_OPEN identifier_list_opt ROUND_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : direct_declarator\n");}
		;


pointer 
		: MUL type_qualifier_list_opt
		{     printf("Rule 2 : DECLARATIONS : pointer\n");}
		| MUL type_qualifier_list_opt pointer
		{     printf("Rule 2 : DECLARATIONS : pointer\n");}
		;


pointer_opt 
		: pointer
		| %empty
		;


assignment_expression_opt 
		: assignment_expression
		| %empty
		;


type_qualifier_list 
		: type_qualifier
		{     printf("Rule 2 : DECLARATIONS : type_qualifier_list\n");}
		| type_qualifier_list type_qualifier
		{     printf("Rule 2 : DECLARATIONS : type_qualifier_list\n");}
		;


type_qualifier_list_opt 
		: type_qualifier_list
		| %empty
		;


parameter_type_list 
		: parameter_list
		{     printf("Rule 2 : DECLARATIONS : parameter_type_list\n");}
		| parameter_list COMMA DOTS
		{     printf("Rule 2 : DECLARATIONS : parameter_type_list\n");}
		;


parameter_list 
		: parameter_declaration
		{     printf("Rule 2 : DECLARATIONS : parameter_list\n");}
		| parameter_list COMMA parameter_declaration
		{     printf("Rule 2 : DECLARATIONS : parameter_list\n");}
		;


parameter_declaration 
		: declaration_specifiers declarator
		{     printf("Rule 2 : DECLARATIONS : parameter_declaration\n");}
		| declaration_specifiers
		{     printf("Rule 2 : DECLARATIONS : parameter_declaration\n");}
		;


identifier_list 
		: IDENTIFIER
		{     printf("Rule 2 : DECLARATIONS : identifier_list\n");}
		| identifier_list COMMA IDENTIFIER
		{     printf("Rule 2 : DECLARATIONS : identifier_list\n");}
		;


identifier_list_opt 
		: identifier_list
		| %empty
		;


type_name 
		: specifier_qualifier_list
		{     printf("Rule 2 : DECLARATIONS : type_name\n");}
		;


initializer 
		: assignment_expression
		{     printf("Rule 2 : DECLARATIONS : initializer\n");}
		| CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : initializer\n");}
		| CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : initializer\n");}
		;


initializer_list 
		: designation_opt initializer
		{     printf("Rule 2 : DECLARATIONS : initializer_list\n");}
		| initializer_list COMMA designation_opt initializer
		{     printf("Rule 2 : DECLARATIONS : initializer_list\n");}
		;


designation 
		: designator_list ASSIGN
		{     printf("Rule 2 : DECLARATIONS : designation\n");}
		;


designation_opt 
		: designation
		| %empty
		;


designator_list 
		: designator
		{     printf("Rule 2 : DECLARATIONS : designator_list\n");}
		| designator_list designator
		{     printf("Rule 2 : DECLARATIONS : designator_list\n");}
		;


designator 
		: SQUARE_BRACKET_OPEN constant_expression SQUARE_BRACKET_CLOSE
		{     printf("Rule 2 : DECLARATIONS : designator\n");}
		| DOT IDENTIFIER
		{     printf("Rule 2 : DECLARATIONS : designator\n");}
		;


// -------------------------------- 3. STATEMENTS ------------------------------


statement 
		: labeled_statement
		{     printf("Rule 3 : STATEMENTS : statement\n");}
		| compound_statement
		{     printf("Rule 3 : STATEMENTS : statement\n");}
		| expression_statement
		{     printf("Rule 3 : STATEMENTS : statement\n");}
		| selection_statement
		{     printf("Rule 3 : STATEMENTS : statement\n");}
		| iteration_statement
		{     printf("Rule 3 : STATEMENTS : statement\n");}
		| jump_statement
		{     printf("Rule 3 : STATEMENTS : statement\n");}
		;


labeled_statement 
		: IDENTIFIER COLON statement
		{     printf("Rule 3 : STATEMENTS : labeled_statement\n");}
		| CASE constant_expression COLON statement
		{     printf("Rule 3 : STATEMENTS : labeled_statement\n");}
		| DEFAULT COLON statement
		{     printf("Rule 3 : STATEMENTS : labeled_statement\n");}
		;


compound_statement 
		: CURLY_BRACKET_OPEN block_item_list_opt CURLY_BRACKET_CLOSE
		{     printf("Rule 3 : STATEMENTS : compound_statement\n");}
		;


block_item_list 
		: block_item
		{     printf("Rule 3 : STATEMENTS : block_item_list\n");}
		| block_item_list block_item
		{     printf("Rule 3 : STATEMENTS : block_item_list\n");}
		;


block_item 
		: declaration
		{     printf("Rule 3 : STATEMENTS : block_item\n");}
		| statement
		{     printf("Rule 3 : STATEMENTS : block_item\n");}
		;


block_item_list_opt 
		: block_item_list
		| %empty
		;


expression_statement 
		: expression_opt SEMICOLON
		{     printf("Rule 3 : STATEMENTS : expression_statement\n");}
		;


expression_opt 
		: expression
		| %empty
		;


selection_statement 
		: IF ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement %prec LOWER_THAN_ELSE;
		//{   printf("Rule 3 : STATEMENTS : selection_statement_only_if\n");}
		| IF ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement ELSE statement
		{   printf("Rule 3 : STATEMENTS : selection_statement_if_else\n");}
		| SWITCH ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement
		{     printf("Rule 3 : STATEMENTS : selection_statement\n");}
		;


iteration_statement 
		: WHILE ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement
		{     printf("Rule 3 : STATEMENTS : iteration_statement\n");}
		| DO statement WHILE ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE SEMICOLON
		{     printf("Rule 3 : STATEMENTS : iteration_statement\n");}
		| FOR ROUND_BRACKET_OPEN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt ROUND_BRACKET_CLOSE statement
		{     printf("Rule 3 : STATEMENTS : iteration_statement\n");}
		| FOR ROUND_BRACKET_OPEN declaration expression_opt SEMICOLON expression_opt ROUND_BRACKET_CLOSE statement
		{     printf("Rule 3 : STATEMENTS : iteration_statement\n");}
		;


jump_statement 
		: GOTO IDENTIFIER SEMICOLON
		{     printf("Rule 3 : STATEMENTS : jump_statement\n");}
		| CONTINUE SEMICOLON
		{     printf("Rule 3 : STATEMENTS : jump_statement\n");}
		| BREAK SEMICOLON
		{     printf("Rule 3 : STATEMENTS : jump_statement\n");}
		| RETURN expression_opt SEMICOLON
		{     printf("Rule 3 : STATEMENTS : jump_statement\n");}
		;


// -------------------------------- 4. EXTERNAL DEFINITIONS  --------------------


translation_unit 
		: external_declaration
		{     printf("Rule 4 : EXTERNAL DEFINITIONS : translation_unit\n");}
		| translation_unit external_declaration
		{     printf("Rule 4 : EXTERNAL DEFINITIONS : translation_unit\n");}
		;


external_declaration
		: function_definition
		{     printf("Rule 4 : EXTERNAL DEFINITIONS : external_declaration\n");}
		| declaration
		{     printf("Rule 4 : EXTERNAL DEFINITIONS : external_declaration\n");}
		;


function_definition
		: declaration_specifiers declarator declaration_list_opt compound_statement
		{     printf("Rule 4 : EXTERNAL DEFINITIONS : function_definition\n");}
		;


declaration_list
		: declaration
		{     printf("Rule 4 : EXTERNAL DEFINITIONS : declaration_list\n");}
        | declaration_list declaration
		{     printf("Rule 4 : EXTERNAL DEFINITIONS : declaration_list\n");}
		;


declaration_list_opt
		: declaration_list
		| %empty
		;


%%

// Called on error in case invalid input is obtained that cannot
// parsed by the parser generated by Bison
void yyerror(char *s) {  
	printf("The error is: %s\n", s);
}

