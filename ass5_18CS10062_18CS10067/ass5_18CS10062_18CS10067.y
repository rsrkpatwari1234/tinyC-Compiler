%{  

//Translator file containing data structures and function prototype
#include "ass5_18CS10062_18CS10067_translator.h"

//Declaration of C++ header files
#include <iostream>              
#include <cstdlib>
#include <string>
#include <stdio.h>
#include <sstream>

using namespace std;

extern string var_type;			// last encountered variable type
extern int yylex(); 			// Generated by Flex
void yyerror(string s);			// error recovery

%}

%union {            			//yylval is a union of all these types
	
	Expression* expr;		   //expression
	Statement* stat;		   //statement	

	char unaryOp;	  			//unaryoperator		
	char* char_value;			//char value

	int instr_number;			//instruction number: for backpatching
	int intval;					//integer value	
	int num_params;				//number of parameters

	symboltype* sym_type;		//symbol type  
	sym* symp;					//symbol
	Array* A;  					//Array type
		
}  

// -------------------------- TOKEN DECLARATION --------------------------------

%token <symp> IDENTIFIER

%token <intval> INTEGER_CONSTANT
%token <char_value> FLOAT_CONSTANT
%token <char_value> CHARACTER_CONSTANT
%token <char_value> STRING_LITERAL

%token ROUND_BRACKET_OPEN ROUND_BRACKET_CLOSE
%token SQUARE_BRACKET_OPEN SQUARE_BRACKET_CLOSE
%token CURLY_BRACKET_OPEN CURLY_BRACKET_CLOSE

%token UNARY_INCREMENT UNARY_DECREMENT NOT
%token MUL DIV MOD PLUS MINUS COMPLEMENT XOR
%token DOT DOTS COMMA QUES_MARK COLON SEMICOLON
%token IMPLIES HASH

%token BITWISE_LEFT BITWISE_RIGHT BITWISE_AND BITWISE_OR
%token LOGICAL_AND LOGICAL_OR
%token LESS_THAN GREATER_THAN LESS_EQUAL GREATER_EQUAL EQUAL NOT_EQUAL

%token ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN PLUS_ASSIGN MINUS_ASSIGN 
%token BITWISE_LEFT_ASSIGN BITWISE_RIGHT_ASSIGN BITWISE_AND_ASSIGN XOR_ASSIGN BITWISE_OR_ASSIGN

%token EXTERN STATIC VOID CHAR SHORT INT LONG FLOAT DOUBLE CONST RESTRICT VOLATILE INLINE SIZEOF TYPEDEF UNION STRUCT

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN 

//Setting precedence for handling Dangling-if-else shift-reduce conflict 
%right "LOWER_THAN_ELSE" ELSE

//Auxillary non-terminals M and N
%type <instr_number> M
%type <stat> N

//unary operator
%type <unaryOp> unary_operator

//number of parameters
%type <num_params> argument_expression_list argument_expression_list_opt

//Expressions
%type <expr>
	expression
	expression_opt
	primary_expression 
	multiplicative_expression
	additive_expression
	shift_expression
	relational_expression
	equality_expression
	AND_expression
	exclusive_OR_expression
	inclusive_OR_expression
	logical_AND_expression
	logical_OR_expression
	conditional_expression
	assignment_expression
	expression_statement

//n dimensional arrays
%type <A> 
	postfix_expression
	unary_expression
	cast_expression

//Statements
%type <stat>  
	statement
	compound_statement
	selection_statement
	iteration_statement
	labeled_statement 
	jump_statement
	block_item
	block_item_list
	block_item_list_opt

//symbol type
%type <sym_type> pointer

//symbol
%type <symp> initializer
%type <symp> direct_declarator init_declarator declarator


// ------------------------ STATING THE STARTING NON-TERMINAL SYMBOL ------------
%start translation_unit

%%

// -------------------------------- 1. EXPRESSIONS ------------------------------

M 		: %empty 
		{
			// backpatching,stores the index of the next quad to be generated
			// Used in various control statements
			$$=nextinstr();
		}   
		;

N 		: %empty
		{
			// backpatching,inserts a goto and stores the index of the next goto statement to guard against fallthrough
			$$ =new Statement();        //we have defined nextlist for Statements
			$$->nextlist=makelist(nextinstr());
			emit("goto","");
		}
		;

primary_expression 
		: IDENTIFIER
		{     
			$$=new Expression(); 
			//create new expression and store pointer to ST entry in the location
			updateNextInstr();		 
			$$->loc=$1;
			updateNextInstr();
			$$->type="not-boolean";
			updateNextInstr();
		}
		| INTEGER_CONSTANT
		{    
			$$=new Expression();	
			updateNextInstr();
			string p=convertIntToString($1);
			updateNextInstr();
			$$->loc=gentemp(new symboltype("int"),p);
			updateNextInstr();
			emit("=",$$->loc->name,p);
			updateNextInstr();
		}
		| FLOAT_CONSTANT				//type is char constant
		{  
			$$=new Expression();	
			updateNextInstr();
			$$->loc=gentemp(new symboltype("float"),$1);
			updateNextInstr();
			emit("=",$$->loc->name,string($1));
			updateNextInstr();
		}
		| CHARACTER_CONSTANT
		{    
			$$=new Expression();	
			updateNextInstr();
			$$->loc=gentemp(new symboltype("char"),$1);
			updateNextInstr();
			emit("=",$$->loc->name,string($1));
			updateNextInstr();
		}
		| STRING_LITERAL
		{   
			$$=new Expression();	
			updateNextInstr();
			$$->loc=gentemp(new symboltype("ptr"),$1);
			updateNextInstr();
			$$->loc->type->arrtype=new symboltype("char");
			updateNextInstr();
		}
		| ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE
		{   
			$$ = $2;
		}
		;

postfix_expression 
		: primary_expression 
		{
			$$=new Array();
			updateNextInstr();
			$$->Array=$1->loc;	
			updateNextInstr();
			$$->type=$1->loc->type;	
			updateNextInstr();
			$$->loc=$$->Array;
			updateNextInstr();
		}
		| postfix_expression SQUARE_BRACKET_OPEN expression SQUARE_BRACKET_CLOSE
		{
			$$=new Array();
			updateNextInstr();
			$$->type=$1->type->arrtype;				// type=type of element	
			updateNextInstr();			
			$$->Array=$1->Array;						// copy the base
			updateNextInstr();
			$$->loc=gentemp(new symboltype("int"));		// store computed address
			updateNextInstr();
			$$->atype="arr";						//atype is arr.
			updateNextInstr();
			if($1->atype=="arr") 
			{
				sym* t=gentemp(new symboltype("int"));
				updateNextInstr();
				int p=computeSize($$->type);
				updateNextInstr();
				string str=convertIntToString(p);
				updateNextInstr();
				emit("*",t->name,$3->loc->name,str);
				updateNextInstr();	
				emit("+",$$->loc->name,$1->loc->name,t->name);
				updateNextInstr();
			}
			else 
			{                        //if a 1D Array, simply calculate size
				int p=computeSize($$->type);
				updateNextInstr();
				string str=convertIntToString(p);
				updateNextInstr();
				emit("*",$$->loc->name,$3->loc->name,str);
				updateNextInstr();
			}
		}
		| postfix_expression ROUND_BRACKET_OPEN argument_expression_list_opt ROUND_BRACKET_CLOSE
		{     
			$$=new Array();	
			updateNextInstr();
			$$->Array=gentemp($1->type);
			updateNextInstr();
			string str=convertIntToString($3);
			updateNextInstr();
			emit("call",$$->Array->name,$1->Array->name,str);
			updateNextInstr();
		}
		| postfix_expression DOT IDENTIFIER      {     }
		| postfix_expression IMPLIES IDENTIFIER  {     }
		| postfix_expression UNARY_INCREMENT
		{
			$$=new Array();
			updateNextInstr();
			$$->Array=gentemp($1->Array->type);
			updateNextInstr();	
			emit("=",$$->Array->name,$1->Array->name);
			updateNextInstr();
			emit("+",$1->Array->name,$1->Array->name,"1");
			updateNextInstr();    
		}
		| postfix_expression UNARY_DECREMENT
		{
			$$=new Array();
			updateNextInstr();
			$$->Array=gentemp($1->Array->type);
			updateNextInstr();	
			emit("=",$$->Array->name,$1->Array->name);
			updateNextInstr();
			emit("-",$1->Array->name,$1->Array->name,"1");
			updateNextInstr();    
		}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE       {	    }
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE {		}
		;


argument_expression_list_opt 
	  	: argument_expression_list
	  	{
	  		$$ = $1;
	  	}
	  	| %empty
	  	{
	  		$$ = 0;
	  	}
	  	;


argument_expression_list 
		: assignment_expression
		{    
			$$=1;                                   //one argument and emit param
			updateNextInstr();
			emit("param",$1->loc->name);	
			updateNextInstr();
		}
	  	| argument_expression_list COMMA assignment_expression
	    {
			$$=$1+1;                          //one more argument and emit param
			updateNextInstr();
			emit("param",$3->loc->name);	
			updateNextInstr();
	    }
	  	;


unary_expression 
		: postfix_expression
		{
			$$ = $1;    
		}
		| UNARY_INCREMENT unary_expression
		{
			emit("+",$2->Array->name,$2->Array->name,"1");
			updateNextInstr();
			$$=$2;
			updateNextInstr();   
		}
		| UNARY_DECREMENT unary_expression
		{
			emit("-",$2->Array->name,$2->Array->name,"1");
			updateNextInstr();
			$$=$2;
			updateNextInstr();   
		}
		| unary_operator cast_expression
		{      	
			$$=new Array();
			updateNextInstr();
			switch($1)
			{	  
				case '&':                                       //address of something, then generate a pointer temporary and emit the quad
					
					$$->Array=gentemp((new symboltype("ptr")));
					updateNextInstr();
					$$->Array->type->arrtype=$2->Array->type; 
					updateNextInstr();
					emit("=&",$$->Array->name,$2->Array->name);
					updateNextInstr();
					break;

				case '*':                          //value of something, then generate a temporary of the corresponding type and emit the quad	
					$$->atype="ptr";
					updateNextInstr();
					$$->loc=gentemp($2->Array->type->arrtype);
					updateNextInstr();
					$$->Array=$2->Array;
					updateNextInstr();
					emit("=*",$$->loc->name,$2->Array->name);
					updateNextInstr();
					break;

				case '+':  
					$$=$2;
					break;
					                    //unary plus, do nothing
				case '-':				   //unary minus, generate new temporary of the same base type and make it negative of current one
					$$->Array=gentemp(new symboltype($2->Array->type->type));
					updateNextInstr();
					emit("MINUS",$$->Array->name,$2->Array->name);
					updateNextInstr();
					break;

				case '~':                   //bitwise not, generate new temporary of the same base type and make it negative of current one
					$$->Array=gentemp(new symboltype($2->Array->type->type));
					updateNextInstr();
					emit("~",$$->Array->name,$2->Array->name);
					updateNextInstr();
					break;

				case '!':				//logical not, generate new temporary of the same base type and make it negative of current one
					$$->Array=gentemp(new symboltype($2->Array->type->type));
					updateNextInstr();
					emit("!",$$->Array->name,$2->Array->name);
					updateNextInstr();
					break;
			}
		}
		| SIZEOF unary_expression 									{	}
		| SIZEOF ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE	{	}
		;


unary_operator
		: BITWISE_AND
		{
			$$ = '&';
			updateNextInstr();
		}
		| MUL
		{
			$$ = '*';
			updateNextInstr();
		}
		| PLUS
		{
			$$ = '+';
			updateNextInstr();
		}
		| MINUS
		{
			$$ = '-';
			updateNextInstr();
		}
		| COMPLEMENT
		{
			$$ = '~';
			updateNextInstr();
		}
		| NOT
		{
			$$ = '!';
			updateNextInstr();
		}
		;


cast_expression 
		: unary_expression
		{
			$$ = $1;     
		}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE cast_expression
		{ 
			$$=new Array();	
			updateNextInstr();
			$$->Array=convertType($4->Array,var_type); 
			updateNextInstr();
		}
		;


multiplicative_expression 
		: cast_expression
		{
			$$ = new Expression();             //generate new expression	
			updateNextInstr();						    
			if($1->atype=="arr") 			   //if it is of type arr
			{
				$$->loc = gentemp($1->loc->type);	
				updateNextInstr();
				emit("=[]",  $$->loc->name,$1->Array->name, $1->loc->name);     //emit with Array right
				updateNextInstr();
			}
			else if($1->atype=="ptr")         //if it is of type ptr
			{ 
				$$->loc = $1->loc;        //equate the locs
				updateNextInstr();
			}
			else
			{
				$$->loc = $1->Array;
				updateNextInstr();
			}
		}
		| multiplicative_expression MUL cast_expression
		{ 
			debug();
			if(!compareSymbolType($1->loc, $3->Array))         
				cout<<"Type Error in Program"<< endl;	// error
			else 
	//if types are compatible, generate new temporary and equate to the product
			{
				$$ = new Expression();	
				updateNextInstr();
				$$->loc = gentemp(new symboltype($1->loc->type->type));
				updateNextInstr();
				emit("*",$$->loc->name,$1->loc->name, $3->Array->name);
				updateNextInstr();
			}
		}
		| multiplicative_expression DIV cast_expression
		{ 
			debug();
			if(!compareSymbolType($1->loc, $3->Array))         
				cout<<"Type Error in Program"<< endl;	// error
			else 
	//if types are compatible, generate new temporary and equate to the product
			{
				$$ = new Expression();	
				updateNextInstr();
				$$->loc = gentemp(new symboltype($1->loc->type->type));
				updateNextInstr();
				emit("/",$$->loc->name,$1->loc->name, $3->Array->name);
				updateNextInstr();
			}
		}
		| multiplicative_expression MOD cast_expression
		{ 
			debug();
			if(!compareSymbolType($1->loc, $3->Array))         
				cout<<"Type Error in Program"<< endl;	// error
			else 
	//if types are compatible, generate new temporary and equate to the product
			{
				$$ = new Expression();	
				updateNextInstr();
				$$->loc = gentemp(new symboltype($1->loc->type->type));
				updateNextInstr();
				emit("%",$$->loc->name,$1->loc->name, $3->Array->name);
				updateNextInstr();
			}
		}
		;


additive_expression 
		: multiplicative_expression
		{ 
			$$ = $1;   
		}
		| additive_expression PLUS multiplicative_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc))
				cout << "Type Error in Program"<< endl;
			else    	//if types are compatible, generate new temporary and equate to the sum
			{
				$$ = new Expression();	
				updateNextInstr();
				$$->loc = gentemp(new symboltype($1->loc->type->type));
				updateNextInstr();
				emit("+",$$->loc->name, $1->loc->name, $3->loc->name);
				updateNextInstr();
			}
		}
		| additive_expression MINUS multiplicative_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc))
				cout << "Type Error in Program"<< endl;
			else    	//if types are compatible, generate new temporary and equate to the sum
			{
				$$ = new Expression();	
				updateNextInstr();
				$$->loc = gentemp(new symboltype($1->loc->type->type));
				updateNextInstr();
				emit("-",$$->loc->name, $1->loc->name, $3->loc->name);
				updateNextInstr();
			}
		}
		;


shift_expression 
		: additive_expression
		{
			$$ = $1;  
		}
		| shift_expression BITWISE_LEFT additive_expression
		{ 
			debug();
			if(!($3->loc->type->type == "int"))
				cout << "Type Error in Program"<< endl; 		
			else            //if base type is int, generate new temporary and equate to the shifted value
			{		
				$$ = new Expression();	
				updateNextInstr();
				$$->loc = gentemp(new symboltype("int"));
				updateNextInstr();
				emit("<<",$$->loc->name, $1->loc->name, $3->loc->name);
				updateNextInstr();
			}
		}
		| shift_expression BITWISE_RIGHT additive_expression
		{ 
			debug();
			if(!($3->loc->type->type == "int"))
				cout << "Type Error in Program"<< endl; 		
			else            //if base type is int, generate new temporary and equate to the shifted value
			{		
				$$ = new Expression();	
				updateNextInstr();
				$$->loc = gentemp(new symboltype("int"));
				updateNextInstr();
				emit(">>", $$->loc->name, $1->loc->name, $3->loc->name);
				updateNextInstr();
			}
		}
		;


relational_expression 
		: shift_expression
		{ 
			$$ = $1;
		}
		| relational_expression LESS_THAN shift_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc)) 
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{      //check compatible types									
				$$ = new Expression();
				updateNextInstr();
				$$->type = "bool";                         //new type is boolean
				updateNextInstr();		
				$$->truelist = makelist(nextinstr());     //makelist for truelist and falselist
				updateNextInstr();
				$$->falselist = makelist(nextinstr()+1);
				updateNextInstr();
				emit("<","",$1->loc->name, $3->loc->name);
				//emit statement if a<b goto .. 
				updateNextInstr();
				emit("goto", "");	//emit statement goto ..
				updateNextInstr();
			}
		}
		| relational_expression GREATER_THAN shift_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc)) 
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{      //check compatible types									
				$$ = new Expression();
				updateNextInstr();
				$$->type = "bool";                         //new type is boolean
				updateNextInstr();		
				$$->truelist = makelist(nextinstr());     //makelist for truelist and falselist
				updateNextInstr();
				$$->falselist = makelist(nextinstr()+1);
				updateNextInstr();
				emit(">","",$1->loc->name, $3->loc->name);
				//emit statement if a<b goto .. 
				updateNextInstr();
				emit("goto", "");	//emit statement goto ..
				updateNextInstr();
			}
		}
		| relational_expression LESS_EQUAL shift_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc)) 
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{      //check compatible types									
				$$ = new Expression();
				updateNextInstr();
				$$->type = "bool";                         //new type is boolean
				updateNextInstr();		
				$$->truelist = makelist(nextinstr());     //makelist for truelist and falselist
				updateNextInstr();
				$$->falselist = makelist(nextinstr()+1);
				updateNextInstr();
				emit("<=","",$1->loc->name, $3->loc->name);
				//emit statement if a<b goto .. 
				updateNextInstr();
				emit("goto", "");	//emit statement goto ..
				updateNextInstr();
			}
		}
		| relational_expression GREATER_EQUAL shift_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc)) 
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{      //check compatible types									
				$$ = new Expression();
				updateNextInstr();
				$$->type = "bool";                         //new type is boolean
				updateNextInstr();		
				$$->truelist = makelist(nextinstr());     //makelist for truelist and falselist
				updateNextInstr();
				$$->falselist = makelist(nextinstr()+1);
				updateNextInstr();
				emit(">=","",$1->loc->name, $3->loc->name);
				//emit statement if a<b goto .. 
				updateNextInstr();
				emit("goto", "");	//emit statement goto ..
				updateNextInstr();
			}
		}
		;


equality_expression 
		: relational_expression
		{
			$$ = $1;   
		}
		| equality_expression EQUAL relational_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc))     //check compatible types
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{
				convertBoolToInt($1);                  //convert bool to int
				updateNextInstr();	
				convertBoolToInt($3);
				updateNextInstr();
				$$ = new Expression();
				updateNextInstr();
				$$->type = "bool";
				updateNextInstr();
				$$->truelist = makelist(nextinstr());//make lists for new expre
				updateNextInstr();
				$$->falselist = makelist(nextinstr()+1); 
				updateNextInstr();
				emit("==", "", $1->loc->name, $3->loc->name);      
				//emit if a==b goto ..
				updateNextInstr();
				emit("goto", "");				//emit goto ..
				updateNextInstr();
			}
			
		}
		| equality_expression NOT_EQUAL relational_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc))  //check compatible types
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{
				convertBoolToInt($1);                  //convert bool to int
				updateNextInstr();	
				convertBoolToInt($3);
				updateNextInstr();
				$$ = new Expression();
				updateNextInstr();
				$$->type = "bool";
				updateNextInstr();
				$$->truelist = makelist(nextinstr());//make lists for new expre
				updateNextInstr();
				$$->falselist = makelist(nextinstr()+1); 
				updateNextInstr();
				emit("!=", "", $1->loc->name, $3->loc->name);      
				//emit if a==b goto ..
				updateNextInstr();
				emit("goto", "");				//emit goto ..
				updateNextInstr();
			}
			
		}
		;


AND_expression 
		: equality_expression
		{
			$$ = $1; 
		}
		| AND_expression BITWISE_AND equality_expression
		{
			debug();
			if(!compareSymbolType($1->loc, $3->loc))//check compatible types 
			{	
				cout << "Type Error in Program"<< endl;
			}
			else 
			{            
				convertBoolToInt($1);                      //convert bool to int
				updateNextInstr();
				convertBoolToInt($3);
				updateNextInstr();
				$$ = new Expression();
				updateNextInstr();
				$$->type = "not-boolean";                  //result is not boolean
				updateNextInstr();
				$$->loc = gentemp(new symboltype("int"));
				updateNextInstr();
				emit("&", $$->loc->name, $1->loc->name,$3->loc->name);
				//emit the quad
				updateNextInstr();
			}
		}
		;


exclusive_OR_expression 
		: AND_expression
		{
			$$ = $1;    
		}
		| exclusive_OR_expression XOR AND_expression
		{
			debug();
			//same as and_expression: check compatible types, make non-boolean expression and convert bool to int and emit
			if(!compareSymbolType($1->loc, $3->loc))    
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{
				convertBoolToInt($1);	
				updateNextInstr();
				convertBoolToInt($3);
				updateNextInstr();
				$$ = new Expression();
				updateNextInstr();
				$$->type = "not-boolean";
				updateNextInstr();
				$$->loc = gentemp(new symboltype("int"));
				updateNextInstr();
				emit("^", $$->loc->name, $1->loc->name, $3->loc->name);
				updateNextInstr();
			}
		}
		;


inclusive_OR_expression 
		: exclusive_OR_expression
		{
			$$ = $1;     
		}
		| inclusive_OR_expression BITWISE_OR exclusive_OR_expression
		{ 
			debug();
			if(!compareSymbolType($1->loc, $3->loc))   //same as and_expression: check compatible types, make non-boolean expression and convert bool to int and emit
			{
				cout << "Type Error in Program"<< endl;
			}
			else 
			{
				convertBoolToInt($1);		
				updateNextInstr();
				convertBoolToInt($3);
				updateNextInstr();
				$$ = new Expression();
				updateNextInstr();
				$$->type = "not-boolean";
				updateNextInstr();
				$$->loc = gentemp(new symboltype("int"));
				updateNextInstr();
				emit("|", $$->loc->name, $1->loc->name, $3->loc->name);
				updateNextInstr();
			} 
		}
 		;


logical_AND_expression 
		: inclusive_OR_expression
		{
			$$ = $1;    
		}
		| logical_AND_expression N LOGICAL_AND M inclusive_OR_expression
		{ 
			debug();
			convertIntToBool($5);    //convert inclusive_or_expression int to bool
			updateNextInstr();
			backpatch($2->nextlist, nextinstr()); //$2->nextlist goes to next instr
			updateNextInstr();
			convertIntToBool($1); //convert logical_and_expression to bool
			updateNextInstr();
			$$ = new Expression();     //make new boolean expression 
			updateNextInstr();
			$$->type = "bool";
			updateNextInstr();
			backpatch($1->truelist, $4);        //if $1 is true, we move to $5
			updateNextInstr();
			$$->truelist = $5->truelist;        //if $5 is also true, we get truelist for $$
			updateNextInstr();
			$$->falselist = merge($1->falselist, $5->falselist);   
			 //merge their falselists
			updateNextInstr();
		}
		;


logical_OR_expression 
		: logical_AND_expression
		{
			$$ = $1;     
		}
		| logical_OR_expression N LOGICAL_OR M logical_AND_expression
		{ 
			debug();
			convertIntToBool($5);    //convert inclusive_or_expression int to bool
			updateNextInstr();
			backpatch($2->nextlist, nextinstr()); //$2->nextlist goes to next instr
			updateNextInstr();
			convertIntToBool($1); //convert logical_and_expression to bool
			updateNextInstr();
			$$ = new Expression();     //make new boolean expression 
			updateNextInstr();
			$$->type = "bool";
			updateNextInstr();
			backpatch($1->falselist, $4);        //if $1 is true, we move to $5
			updateNextInstr();
			$$->truelist = merge($1->truelist, $5->truelist);
			//if $5 is also true, we get truelist for $$
			updateNextInstr();
			$$->falselist = $5->falselist;
			 //merge their falselists
			updateNextInstr();
		}
		;


conditional_expression 
		: logical_OR_expression
		{
			$$ = $1;   
		}
		| logical_OR_expression N QUES_MARK M expression N COLON M  conditional_expression
		{
			debug();
			//normal conversion method to get conditional expressions
			$$->loc = gentemp($5->loc->type);       
			//generate temporary for expression
			updateNextInstr();
			$$->loc->update($5->loc->type);
			updateNextInstr();
			emit("=", $$->loc->name, $9->loc->name);      
			//make it equal to conditional_expression
			updateNextInstr();
			debug();
			list<int> l = makelist(nextinstr());        //makelist next instruction
			emit("goto", "");              //prevent fallthrough
			updateNextInstr();
			debug();
			backpatch($6->nextlist, nextinstr()); //after N, go to next instruction
			updateNextInstr();
			emit("=", $$->loc->name, $5->loc->name);
			updateNextInstr();
			debug();
			list<int> m = makelist(nextinstr());    //makelist next instruction
			updateNextInstr();
			l = merge(l, m);						//merge the two lists
			updateNextInstr();
			emit("goto", "");						//prevent fallthrough
			updateNextInstr();
			debug();
			backpatch($2->nextlist, nextinstr());   //backpatching
			updateNextInstr();
			convertIntToBool($1);                   //convert expression to boolean
			updateNextInstr();
			backpatch($1->truelist, $4);           //$1 true goes to expression
			updateNextInstr();
			backpatch($1->falselist, $8);          //$1 false goes to conditional_expression
			updateNextInstr();
			backpatch(l, nextinstr());
			updateNextInstr();
		}
		;


assignment_expression 
		: conditional_expression
		{
			$$ = $1;     
		}
		| unary_expression assignment_operator assignment_expression
		{
			debug();
			if($1->atype=="arr")       //if type is arr, simply check if we need to convert and emit
			{
				$3->loc = convertType($3->loc, $1->type->type);
				updateNextInstr();
				emit("[]=", $1->Array->name, $1->loc->name, $3->loc->name);		
				updateNextInstr();
			}
			else if($1->atype=="ptr")     //if type is ptr, simply emit
			{
				emit("*=", $1->Array->name, $3->loc->name);		
				updateNextInstr();
			}
			else                              //otherwise assignment
			{
				$3->loc = convertType($3->loc, $1->Array->type->type);
				emit("=", $1->Array->name, $3->loc->name);
				updateNextInstr();
			}
			
			$$ = $3;
		}
		;


assignment_operator
		: ASSIGN     			{	}
		| MUL_ASSIGN			{	}
		| DIV_ASSIGN			{	}
		| MOD_ASSIGN			{	}
		| PLUS_ASSIGN			{	}
		| MINUS_ASSIGN			{	}
		| BITWISE_LEFT_ASSIGN	{	}
		| BITWISE_RIGHT_ASSIGN	{	}
		| BITWISE_AND_ASSIGN	{	}
		| XOR_ASSIGN			{	}
		| BITWISE_OR_ASSIGN		{	}
		;


expression 
		: assignment_expression
		{
			$$ = $1;   
		}
		| expression COMMA assignment_expression 	{	}
		;


constant_expression 
		: conditional_expression   {	}
		;


// -------------------------------- 2. DECLARATIONS ------------------------------


declaration 
		: declaration_specifiers init_declarator_list_opt SEMICOLON	{	}
		;


init_declarator_list_opt 
		: init_declarator_list 	{	}
		| %empty 				{	}
		;


declaration_specifiers 
		: storage_class_specifier declaration_specifiers_opt	{	}
		| type_specifier declaration_specifiers_opt				{	}
		| type_qualifier declaration_specifiers_opt				{	}
		| function_specifier declaration_specifiers_opt			{	}
		;


declaration_specifiers_opt 
		: declaration_specifiers {	}
		| %empty				 {	}	
		;


init_declarator_list 
		: init_declarator 								{	}
		| init_declarator_list COMMA init_declarator 	{	}
		;


init_declarator 
		: declarator  
		{
			$$=$1;	   
		}
		| declarator ASSIGN initializer
		{
			if($3->val!="") 
				$1->val=$3->val;        //get the initial value and  emit it
			emit("=", $1->name, $3->name);
			updateNextInstr();
		}
		;

storage_class_specifier 
		: EXTERN 	{	}
		| STATIC	{	}
		;

type_specifier 
		: VOID   {  var_type = "void";  }
		| CHAR   {  var_type = "char";  }
		| SHORT  {   					}
		| INT 	 {  var_type = "int";   }
		| LONG   {   					}
		| FLOAT  {  var_type = "float"; }
		| DOUBLE {   					}
		;

specifier_qualifier_list 
		: type_specifier specifier_qualifier_list_opt	{	}
		| type_qualifier specifier_qualifier_list_opt	{	}
		;

specifier_qualifier_list_opt 
		: specifier_qualifier_list  {	}
		| %empty					{	}
		;

type_qualifier 
		: CONST 	{	}
		| RESTRICT	{	}
		| VOLATILE	{	}
		;

function_specifier 
		: INLINE 	{	}
		;

declarator 
		: pointer direct_declarator
		{
			symboltype *t = $1;
			updateNextInstr();
			 //for multidimensional arr1s, move in depth till you get the base type
			while(t->arrtype!=NULL) t = t->arrtype;          
			updateNextInstr();
			t->arrtype = $2->type;                //add the base type 
			updateNextInstr();
			$$ = $2->update($1);                  //update
			updateNextInstr();
		}
		| direct_declarator		{	}
		;


direct_declarator 
		: IDENTIFIER                 //if ID, simply add a new variable of var_type
		{
			$$ = $1->update(new symboltype(var_type));
			updateNextInstr();
			currSymbolPtr = $$;
			updateNextInstr();
		}
		| ROUND_BRACKET_OPEN declarator ROUND_BRACKET_CLOSE  
		{ 
			$$ = $2; 
		}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list assignment_expression SQUARE_BRACKET_CLOSE		{	}
		| direct_declarator SQUARE_BRACKET_OPEN assignment_expression SQUARE_BRACKET_CLOSE		
		{
			symboltype *t = $1 -> type;
			updateNextInstr();
			symboltype *prev = NULL;
			updateNextInstr();
			while(t->type == "arr") 
			{
				prev = t;	
				t = t->arrtype;      //keep moving recursively to get basetype
				updateNextInstr();
			}
			if(prev==NULL) 
			{
				int temp = atoi($3->loc->val.c_str());      //get initial value
				updateNextInstr();
				symboltype* s = new symboltype("arr", $1->type, temp);        //create new symbol with that initial value
				updateNextInstr();
				$$ = $1->update(s);   //update the symbol table
				updateNextInstr();
			}
			else 
			{
				prev->arrtype =  new symboltype("arr", t, atoi($3->loc->val.c_str()));     //similar arguments as above		
				updateNextInstr();
				$$ = $1->update($1->type);
				updateNextInstr();
			}
		}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list    SQUARE_BRACKET_CLOSE		{	}
		| direct_declarator SQUARE_BRACKET_OPEN SQUARE_BRACKET_CLOSE		
		{
			symboltype *t = $1 -> type;
			updateNextInstr();
			symboltype *prev = NULL;
			updateNextInstr();
			while(t->type == "arr") 
			{
				prev = t;	
				t = t->arrtype;         //keep moving recursively to base type
				updateNextInstr();
			}
			if(prev==NULL) 
			{
				symboltype* s = new symboltype("arr", $1->type, 0);    //no initial values, simply keep 0
				updateNextInstr();
				$$ = $1->update(s);
				updateNextInstr();	
			}
			else 
			{
				prev->arrtype =  new symboltype("arr", t, 0);
				updateNextInstr();
				$$ = $1->update($1->type);
				updateNextInstr();
			}
		}
		| direct_declarator SQUARE_BRACKET_OPEN STATIC type_qualifier_list assignment_expression SQUARE_BRACKET_CLOSE		   {   }
		| direct_declarator SQUARE_BRACKET_OPEN STATIC assignment_expression SQUARE_BRACKET_CLOSE		                         {   }
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list STATIC assignment_expression SQUARE_BRACKET_CLOSE          {   }
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list MUL SQUARE_BRACKET_CLOSE                                {   }
		| direct_declarator SQUARE_BRACKET_OPEN MUL SQUARE_BRACKET_CLOSE  {   }
		| direct_declarator ROUND_BRACKET_OPEN changetable parameter_type_list ROUND_BRACKET_CLOSE
		{
			ST->name = $1->name;
			updateNextInstr();
			if($1->type->type !="void") 
			{
				sym *s = ST->lookup("return");         //lookup for return value	
				s->update($1->type);
				updateNextInstr();
			}
			$1->nested=ST;       
			updateNextInstr();	
			ST->parent = globalST;
			updateNextInstr();
			changeTable(globalST);				// Come back to globalsymbol table
			updateNextInstr();
			currSymbolPtr = $$;
			updateNextInstr();
		}
		| direct_declarator ROUND_BRACKET_OPEN changetable ROUND_BRACKET_CLOSE
		{        //similar as above
			ST->name = $1->name;
			updateNextInstr();
			if($1->type->type !="void") 
			{
				sym *s = ST->lookup("return");
				s->update($1->type);
				updateNextInstr();
				debug();			
			}
			$1->nested=ST;
			updateNextInstr();
			ST->parent = globalST;
			updateNextInstr();
			changeTable(globalST);				// Come back to globalsymbol table
			updateNextInstr();
			currSymbolPtr = $$;
			updateNextInstr();
		}
		| direct_declarator ROUND_BRACKET_OPEN identifier_list ROUND_BRACKET_CLOSE
		{   }
		;

changetable
		: %empty 
		{ 														// Used for changing to symbol table for a function
			if(currSymbolPtr->nested==NULL) 
			{
				changeTable(new symtable(""));	// Function symbol table doesn't already exist
				updateNextInstr();
			}
			else 
			{
				changeTable(currSymbolPtr ->nested);						// Function symbol table already exists
				updateNextInstr();
				emit("label", ST->name);
				updateNextInstr();
			}
		}
		;
pointer 
		: MUL type_qualifier_list_opt
		{ 
			$$ = new symboltype("ptr");
			updateNextInstr(); 
		}          //create new pointer
		| MUL type_qualifier_list_opt pointer
		{ 
			$$ = new symboltype("ptr",$3);
			updateNextInstr();
		}
		;

type_qualifier_list 
		: type_qualifier  						{   }
		| type_qualifier_list type_qualifier 	{	}
		;


type_qualifier_list_opt 
		: type_qualifier_list  {	}
		| %empty			   {	}
		;


parameter_type_list 
		: parameter_list 			 {	 }
		| parameter_list COMMA DOTS  {	 }
		;


parameter_list 
		: parameter_declaration							{	}
		| parameter_list COMMA parameter_declaration	{	}
		;


parameter_declaration 
		: declaration_specifiers declarator  	{	}
		| declaration_specifiers 				{	}
		;


identifier_list 
		: IDENTIFIER 						 {    }
		| identifier_list COMMA IDENTIFIER   {	  }
		;


type_name 
		: specifier_qualifier_list {   }
		;


initializer 
		: assignment_expression
		{
			$$ = $1->loc;     //assignment
		}
		| CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE        {  }
		| CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE  {  }
		;


initializer_list 
		: designation_opt initializer 						  {  }
		| initializer_list COMMA designation_opt initializer  {  }
		;


designation 
		: designator_list ASSIGN  {   }
		;


designation_opt 
		: designation 	{	}
		| %empty		{	}
		;


designator_list 
		: designator                 {   }
		| designator_list designator {   }
		;


designator 
		: SQUARE_BRACKET_OPEN constant_expression SQUARE_BRACKET_CLOSE  {   }
		| DOT IDENTIFIER                                                {   }
		;


// -------------------------------- 3. STATEMENTS ------------------------------


statement 
		: labeled_statement  {    }
		| compound_statement
		{	
			$$ = $1;  
		}
		| expression_statement
		{ 
			$$=new Statement();          //create new statement with same nextlist
			$$->nextlist=$1->nextlist; 
		}
		| selection_statement
		{
			$$ = $1;  
		}
		| iteration_statement
		{
			$$ = $1; 
		}
		| jump_statement
		{
			$$ = $1;   
		}
		;


labeled_statement 
		: IDENTIFIER COLON statement 				{	}
		| CASE constant_expression COLON statement  {	}
		| DEFAULT COLON statement 					{	}
		;


compound_statement 
		: CURLY_BRACKET_OPEN block_item_list_opt CURLY_BRACKET_CLOSE  
		{
			$$=$2;	  
		}
		;


block_item_list 
		: block_item
		{
			$$ = $1;              //simply equate
		}
		| block_item_list M block_item
		{
			$$ = $3;			 //simply equate
			backpatch($1->nextlist,$2);		//after $1, move to block_item via $2
		}
		;


block_item 
		: declaration
		{
			$$ = new Statement();    //new statement  
		}
		| statement
		{
			$$ = $1;                 //simply equate   
		}
		;


block_item_list_opt 
		: block_item_list  
		{ 
			$$ = $1;                 //simply equate  
		}
		| %empty           
		{  
			$$ = new Statement();        //new statement
		}
		;


expression_statement 
		: expression_opt SEMICOLON    {   }
		;


expression_opt 
		: expression
		{
			$$ = $1;                      //simply equate
		}
		| %empty
		{
			$$ = new Expression();		   //new expression
		}
		;


selection_statement 
		: IF ROUND_BRACKET_OPEN expression N ROUND_BRACKET_CLOSE M statement N %prec "LOWER_THAN_ELSE"
		{
			backpatch($4->nextlist, nextinstr());//nextlist of N goes to nextinstr
			updateNextInstr();
			convertIntToBool($3);         //convert expression to bool
			updateNextInstr();
			$$ = new Statement();        //make new statement
			updateNextInstr();
			backpatch($3->truelist, $6);        //is expression is true, go to M i.e just before statement body
			updateNextInstr();
			list<int> temp = merge($3->falselist, $7->nextlist);   
			//merge falselist of expression, nextlist of statement and second N
			updateNextInstr();
			$$->nextlist = merge($8->nextlist, temp);
			updateNextInstr();
		}
		| IF ROUND_BRACKET_OPEN expression N ROUND_BRACKET_CLOSE M statement N ELSE M statement
		{
			backpatch($4->nextlist, nextinstr());//nextlist of N goes to nextinstr
			updateNextInstr();
			convertIntToBool($3);        //convert expression to bool
			updateNextInstr();
			$$ = new Statement();       //make new statement
			updateNextInstr();
			backpatch($3->truelist, $6);    //when expression is true, go to M1 else go to M2
			updateNextInstr();
			backpatch($3->falselist, $10);
			updateNextInstr();
			list<int> temp = merge($7->nextlist, $8->nextlist);       
			//merge the nextlists of the statements and second N
			updateNextInstr();
			$$->nextlist = merge($11->nextlist,temp);	
			updateNextInstr();	
		}
		| SWITCH ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement {   }
		;


iteration_statement 
		: WHILE M ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE M statement  
		{
			$$ = new Statement();    //create statement
			updateNextInstr();
			convertIntToBool($4);     //convert expression to bool
			updateNextInstr();
			backpatch($7->nextlist, $2);	// M1 to go back to expression again
			updateNextInstr();
			backpatch($4->truelist, $6);	// M2 to go to statement if the expression is true
			updateNextInstr();
			$$->nextlist = $4->falselist;   //when expression is false, move out of loop
			updateNextInstr();
			// Emit to prevent fallthrough
			string str=convertIntToString($2);			
			updateNextInstr();
			emit("goto", str);
			updateNextInstr();	
		}
		| DO M statement M WHILE ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE SEMICOLON
		{
			$$ = new Statement();     //create statement
			updateNextInstr();
			convertIntToBool($7);      //convert to bool
			updateNextInstr();
			backpatch($7->truelist, $2);						// M1 to go back to statement if expression is true
			updateNextInstr();
			backpatch($3->nextlist, $4);						// M2 to go to check expression if statement is complete
			updateNextInstr();
			$$->nextlist = $7->falselist;                       //move out if statement is false
			updateNextInstr();	
		}
		| FOR ROUND_BRACKET_OPEN expression_statement M expression_statement ROUND_BRACKET_CLOSE M statement
		{
			$$ = new Statement();   //create new statement
			updateNextInstr();
			convertIntToBool($5);    //convert check expression to boolean
			updateNextInstr();
			backpatch($5->truelist,$7);        //if expression is true, go to M2
			updateNextInstr();
			backpatch($8->nextlist,$4);        //after statement, go back to M1
			updateNextInstr();
			string str=convertIntToString($4);
			updateNextInstr();
			emit("goto", str);                 //prevent fallthrough
			updateNextInstr();
			$$->nextlist = $5->falselist;      //move out if statement is false
			updateNextInstr();
		}
		| FOR ROUND_BRACKET_OPEN expression_statement M expression_statement M expression N ROUND_BRACKET_CLOSE M statement
		{
			$$ = new Statement();		 //create new statement
			updateNextInstr();
			convertIntToBool($5);  //convert check expression to boolean
			updateNextInstr();
			backpatch($5->truelist, $10);	//if expression is true, go to M2
			updateNextInstr();
			backpatch($8->nextlist, $4);	//after N, go back to M1
			updateNextInstr();
			backpatch($11->nextlist, $6);	//statement go back to expression
			updateNextInstr();
			string str=convertIntToString($6);
			updateNextInstr();
			emit("goto", str);				//prevent fallthrough
			updateNextInstr();
			$$->nextlist = $5->falselist;	//move out if statement is false	
			updateNextInstr();	
		}
		;


jump_statement 
		: GOTO IDENTIFIER SEMICOLON
		{
			$$ = new Statement();  
		}
		| CONTINUE SEMICOLON
		{
			$$ = new Statement();     
		}
		| BREAK SEMICOLON
		{
			$$ = new Statement();     
		}
		| RETURN expression SEMICOLON
		{
			$$ = new Statement();
			updateNextInstr();
			//emit return with the name of the return value
			emit("return",$2->loc->name);
			updateNextInstr();
		}
		| RETURN SEMICOLON
		{
			$$ = new Statement();
			updateNextInstr();
			emit("return","");                         //simply emit return
			updateNextInstr();
		}
		;


// -------------------------------- 4. EXTERNAL DEFINITIONS  --------------------


translation_unit 
		: external_declaration                   {   }
		| translation_unit external_declaration  {   }
		;


external_declaration
		: function_definition  {	}
		| declaration          {    }
		;


function_definition
		: declaration_specifiers declarator declaration_list_opt changetable compound_statement
		{
			updateNextInstr();
			ST->parent=globalST;
			updateNextInstr();
			changeTable(globalST);                     //once we come back to this at the end, change the table to global Symbol table
			updateNextInstr();
		}
		;


declaration_list
		: declaration                   {   }
        | declaration_list declaration  {   }
		;


declaration_list_opt
		: declaration_list  {   }
		| %empty            {   }
		;


%%

// Called on error in case invalid input is obtained that cannot
// parsed by the parser generated by Bison
void yyerror(string str) {  
	cout << str << endl;
}

