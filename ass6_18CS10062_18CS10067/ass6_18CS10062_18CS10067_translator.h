#ifndef ASS6_18CS10062_18CS10067_TRANSLATOR_H
#define ASS6_18CS10062_18CS10067_TRANSLATOR_H

#include <stdio.h>
#include <vector>
#include <cstdlib>
#include <string>
#include <set>
#include <map>
#include <stack>

// macros
#define str string
#define intvec vector<int>
#define strvec vector<str>
#define typvec vector<types>
#define quadvec vector<quad>
#define expvec vector<expresn*>
#define symvec vector<symdata*>

using namespace std;

// external variables
extern map<int, int> mp_set;
// sizes of basic data types
extern int INT_SIZE;
extern int PTR_SIZE;
extern int BOOL_SIZE;
extern int CHAR_SIZE;
extern int DOUBLE_SIZE;
// external variables
extern stack<str> params_stack, strin;
extern stack<int> types_stack, offset_stack, ptrarr_stack;
extern strvec strings_label;	
extern long long int instr_count;			// denotes count of instr
extern bool debug_on;			// bool for printing debug output

// classes
class type_n;
class expresn;
class quad; 
class symdata; 
class symtab;
class quad_arr; 
class funct;
class array;

//vd totest(Str x);//to test
struct decStr;

// structs for identifier, expressions and list of all seen arguments 
struct identifier;
struct expresn;
struct argsList;

// external variables
extern type_n *glob_type;
extern int next_instr, temp_count; 
extern symtab *glob_st, *curr_st; //Global symbol table pointer
extern quad_arr glob_quad; //to store all the quads that will be generated by the grammar

// data type codes (void, boolean, array, function, character, integer, double and pointer)
enum types
{
	tp_void=0,	
	tp_bool,
	tp_arr,	
	tp_func,
	tp_char,	
	tp_int,
	tp_double,	
	tp_ptr,
};

// linked list of indices for storing addresses
typedef struct list
{
	int index;
	struct list *next;
}list;

enum opcode{
	//Binary Assignment Operator
	Q_PLUS=1,
	Q_MINUS,
	Q_MULT,
	Q_DIVIDE,
	Q_MODULO,
	Q_LEFT_OP,
	Q_RIGHT_OP,
	Q_XOR,
	Q_AND,
	Q_OR,
	Q_LOG_AND,
	Q_LOG_OR,
	Q_LESS,
	Q_LESS_OR_EQUAL,
	Q_GREATER_OR_EQUAL,
	Q_GREATER,
	Q_EQUAL,
	Q_NOT_EQUAL,

	//Unary Assignment Operator
	Q_UNARY_MINUS,
	Q_UNARY_PLUS,
	Q_COMPLEMENT,
	Q_NOT,

	//Copy Assignment
	Q_ASSIGN,
	Q_GOTO,

	//Conditional Jump
	IF_EQUAL,
	IF_NOT_EQUAL,
	IF_EXPRESSION,
	IF_NOT_EXPRESSION,
	IF_LESS,
	IF_GREATER,
	IF_LESS_OR_EQUAL,
	IF_GREATER_OR_EQUAL,

	//Type Conversions
	CHAR2INT,
	CHAR2DOUBLE,
	INT2CHAR,
	DOUBLE2CHAR,
	INT2DOUBLE,
	DOUBLE2INT,

	//Procedure Call
	PARAM,
	Q_CALL,
	RETURN_CODE,

	//Pointer Assignment Operator
	Q_LDEREF,
	Q_RDEREF,
	Q_ADDR,

	//Array Indexing
	Q_RINDEX,
	Q_LINDEX,
};

//it is the basic type that an element can have
union basic_val
{
	int int_val;
	double double_val;
	char char_val;
};



class type_n{
public:
	int size;    // to save the size of the type
	types basetp; // to save the basic type of the elemnt
	type_n *next; // to save next type_n type for arrays
	type_n(types t,int sz=1, type_n *n=NULL); //constuctor
	int getSize(); //returns the size
	types getBasetp(); //return Base type
	void printSize(); //to print the size
	void print(); 
};



class array
{
public:

	/* Stores the array base and the variable containing array offset */
	str base_arr;
	array(str ,int ,types );
	types tp;
	/* Stores array dimensions */
	intvec dims;
	int bsize, dimension_size;
	void addindex(int);

};

/* To store details of functions, its parameters and return type */
class funct
{
public:
	/* Parameter type list */
	typvec typelist;

	/* Return type */
	type_n *rettype;

	funct(typvec);
	/* Prints details in suitable format */
	void print();
};


// class which will be used as building element for symbol table
class symdata{
public:
	str name, var_type;
	int offset, size;
	basic_val i_val;//to store the initialized value for an element stored at symbol table
	type_n *tp_n;//for storing the type of element
	symtab *nest_tab; //to store the pointer to the symbol table to which the current element belongs to
	array *arr;//to store the pointer to an array if its an array type
	funct *fun;//to store the pointer to a function if its an function
	// vd createarray();
	symdata(str n=""); //name is initialized to null that will be used for naming temporary variables
	bool isGlobal,isdone,ispresent,isptrarr,isArray, isFunction, isInitialized;
};	

class symtab{
public:
	str name;			// name of the symbol
	int offset, start_quad, end_quad;				// final offset of this symbol table that will be used in the update function
	symvec symbol_tab; //maintaining a list of symbol tables
	symtab();  //constructor
	~symtab(); //destructor
	symdata* lookup(str );// Lookup function searches the variable with name. If the variable is present then returns its pointer location else creates a new entry with its name and returns that pointer
	symdata* lookup_2(str );//To handle global variables
	symdata* search(str ); //it searches for the variable and returns the oiter to it if present
	symdata* gentemp(type_n* ); //gentemp creates a new element in the symbol table with the type provided at the time of constructing
	int num_params;
	void print();
	void update(symdata*, type_n*, basic_val, symtab *next = NULL); //	
	void mark_labels();
	void function_prologue(FILE*, int);
	void global_variables(FILE*);
	void gen_internal_code(FILE*, int);
	int function_call(FILE*);
	void function_epilogue(FILE*, int, int);
	str assign_reg(int , int); // assign register according to data type
	void assign_offset(); // assign 
	void function_restore(FILE*);
	int findg(str);
};

struct expresn{
	symdata* loc;
	type_n* type;
	list* falselist, *truelist;
	bool isArray,isPointer,isString;
	int ind_str;
	symdata *poss_array,*arr;
};

list* makelist(int);  
list* merge(list*, list*); 
type_n* duplicateType(type_n*);

void debug();
void print_list(list*);
void update_nextinstr();
void conv2Bool(expresn*); //to convert the given exprssion type to bool mostly used in relational operator
void backpatch(list*, int);  //to fill the dangling list of goto's l1 to i
void compareExpType(expresn*, expresn*, bool isAss = false);

// struct for declaration grammar
// 1. it has type of declaration 
// 2. width of the varaible
struct decStr
{
	type_n *type;				// type of the current declaration
	int width;					// width of the variable
};

// class for quads
// It has:
// 1. first argument
// 2. result
// 3. second argument
// member functions:
// 1. print_arg to print the instruction
class quad{
public:
	str arg1, result, arg2; 
	opcode op;
	void print_arg();
	quad(opcode, str, str, str); // constructor
};

// Store locations of all seen arguments
struct argsList {
	expvec *arguments;		
};

// struct for a identifier
// It has:
// 1. Pointer to symbol table 
// 2. name of identifier
struct identifier {
	symdata *loc;					
	str *name;						
};

// class for quad array
// It has:
// 1. vector of quad objects, to store the quads
// member functions:
// 1. emit for 1)3 inputs 2)emit for int assignment 3) emit for double assignment 4) emit for char assignment
// 2. function to print quads
class quad_arr{
	public:
		quadvec arr;
		quad_arr(); // constructor
		void emit(opcode, str def1="", str def2="", str res=""); 
		void emit(opcode, int, str operand="");  
		void emit(opcode, double, str operand=""); 
		void emit(opcode, char, str operand=""); 
		void emit2(opcode, str arg1="", str arg2="", str res="");
		void print();  
};

#endif
